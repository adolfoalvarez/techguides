# CI/CD pypelines for automatic deployment of a shiny app

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE, eval = FALSE)
```

It is good practice to structure a Shiny app in a package, as then one can take full advantage of all the automation features already established for an R package (e.g. automatic testing, `R CMD checks`).

A packaged Shiny app can also take advantage of:

- Continuous Integration (CI) pipelines to automate checks and ensure higher code quality and robustness;
- Continuous Deployment (CD) pipelines to automate the process of deployment to a productive environment.

This guide is an illustration of how to set up Continuous Integration (CI) and Continuous Deployment (CD) workflows on popular open source services as Travis CI and GitHub Actions for a packaged Shiny app. [ShinyCICD](https://github.com/miraisolutions/ShinyCICD) is a minimal example of a packaged Shiny app. A simple development workflow to package a Shiny app is provided by the [`golem` package](https://cran.r-project.org/web/packages/golem/index.html).

## Generic CI/CD pipeline

Generally speaking, a CI/CD pipleline for an R package is comprised of the following steps:

- define system
- install R
- chaching system environment
- check out the package
- install package dependencies
- chaching dependencies
- install package
- run checks
- caching build
- deploy

## Travis

Travis CI is an open-source continuous integration service that can be used to build and test software projects hosted on GitHub. To set up Travis CI you need to login at [https://travis-ci.com/](https://travis-ci.com/) (using your GitHub account).

To setup Travis in a project use:

```{r, eval = F}
usethis::use_travis(ext = "com")
```

This will generate a generic `.travis.yaml` file

```{yaml, eval = F}
# R for travis: see documentation at https://docs.travis-ci.com/user/languages/r

language: R
cache: packages
```

As default, Travis CI runs basic package installation (including dependencies) and performs `R CMD Checks`, triggered upon any push event on the GitHub repo in the `master` branch.

ADD SCREENSHOT

Travis CI can be setup to automatically perform a deployment (e.g. publish a shiny app on shinyapps.io or render a website on gitHub Pages) upon any push to the `master` branch.

This can be achieved by extending the `.travis.yaml` file with an appropriate `deploy:` section. 

```{yaml, eval = F}
# R for travis: see documentation at https://docs.travis-ci.com/user/languages/r

language: R
cache: packages

deploy:
 WHAT GOES HERE EXACTLY ???
  on:
    branch: master
```

where `GITHUB_PAT` is a secure variable defined on Travis and referring to a [Personal Access Token (PAT) on GitHub](https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line).

## GitHub Actions

[GitHub Actions](https://help.github.com/en/actions) is a service for completely customizable, GitHub integrated workflow, including CI and CD executions.
Workflows use `YAML` syntax and should be stored in the `.github/workflows` directory in the root of your repository.
They are constituted of jobs and each job is a set of steps to perform individual tasks, e.g. commands or actions.
You can [configure a workflow](https://help.github.com/en/actions/configuring-and-managing-workflows/configuring-a-workflow) to start when a GitHub event occurs, on a schedule, or from an external event.

A workflow should have an identifying name and an `on` section indicating upon which event the workflow should be triggered. It should include at least one job and each job will have a set of steps fully specifying what to execute and where. Such steps can be a (predefined) action or a script, however for the time being GitHub Actions does not support a hierarchical, aggregated structure of actions. Being fully customizable, it is necessary to fully specify each step in the CI/CD pipeline explicitely.

### Action to checkout an R package

In this example the job and the workflow are both called `CI-CD` and run upon push commands and pull requests on the `master` branch, which is the default. It uses the predefined and built in action `checkout@v2` to check out the R package.

```{yaml, eval = F}
# Check on push and pull requests to master
on: [push, pull_request]

# Name of the workflow
name: CI-CD

jobs:
  CI-CD:
    runs-on: ubuntu-latest
    steps:

      - uses: actions/checkout@v2

      - uses: r-lib/actions/setup-r@master
```

### Steps to install the R package

To install an R package we should first take care of its dependencies. This means checking them out and making sure they are cached for future builds.

```{yaml, eval = F}
# Query and cache R package dependencies
      - name: Query dependencies
        run: |
          install.packages("remotes")
          saveRDS(remotes::dev_package_deps(dependencies = TRUE), "depends.Rds", version = 2)
        shell: Rscript {0}
      - name: Cache R packages
        uses: actions/cache@v1
        with:
          path: ${{ env.R_LIBS_USER }}
          key: ${{ runner.os }}-r-${{ hashFiles('depends.Rds') }}
          restore-keys: ${{ runner.os }}-r-
```

Then the package can be installed

```{yaml, eval = F}
      - name: Install dependencies
        run: |
          remotes::install_deps(dependencies = TRUE)
        shell: Rscript {0}
```

### Step to perform automatic checks

This step should occur after checking out and installing the R package. It explicitely requests to run `rcmdcheck::rcmdcheck`, therefore we should make sure that the package is available.

```{yaml, eval = F}
      - name: Install rcmdcheck
        run: |
          remotes::install_cran(c("rcmdcheck"))
        shell: Rscript {0}

      - name: Check package
        run: rcmdcheck::rcmdcheck(args = "--no-manual", error_on = "warning", check_dir = "check")
        shell: Rscript {0}
```

### Automatic Deployment

Adding the deployment is another step in a `CI-CD` job. In the following example it is shown how to trigger a deployment to `shinyapps.io` upon any push or pull request to `master`. notice that it requires the package `rsconnect` to be available.

```{yaml, eval = F}
# Install rsconnect necessary for deployment
      - name: Install dependencies
        run: |
          remotes::install_deps(dependencies = TRUE)
          remotes::install_cran(c("rsconnect"))
        shell: Rscript {0}
        
      - name: Deploy to shinyapps.io
        if: github.ref == 'refs/heads/master'
        env:
          SHINYAPPS_ACCOUNT: ${{ secrets.SHINYAPPS_ACCOUNT }}
          SHINYAPPS_TOKEN: ${{ secrets.SHINYAPPS_TOKEN }}
          SHINYAPPS_SECRET: ${{ secrets.SHINYAPPS_SECRET }}
        run: |
          account_info <- lapply(paste0("SHINYAPPS_", c("ACCOUNT", "TOKEN", "SECRET")), Sys.getenv)
          do.call(rsconnect::setAccountInfo, account_info)
          rsconnect::deployApp(appName = "ShinyCICD")
        shell: Rscript {0}
```

The variables `SHINYAPPS_ACCOUNT`, `SHINYAPPS_TOKEN` and `SHINYAPPS_SECRET` are secure variable defined on `shinyapps.io` and stored on GitHub Actions as [secrets](https://help.github.com/en/actions/configuring-and-managing-workflows/using-variables-and-secrets-in-a-workflow).

### Putting it all together

The final `yml` file would look like:

```{yaml, eval = F}
# Check on push and pull requests to master
on: [push, pull_request]

# Name of the workflow
name: CI-CD

jobs:
  CI-CD:
    runs-on: ubuntu-latest
    steps:

      - uses: actions/checkout@v2

      - uses: r-lib/actions/setup-r@master

# Query and cache R package dependencies
      - name: Query dependencies
        run: |
          install.packages("remotes")
          saveRDS(remotes::dev_package_deps(dependencies = TRUE), "depends.Rds", version = 2)
        shell: Rscript {0}
      - name: Cache R packages
        uses: actions/cache@v1
        with:
          path: ${{ env.R_LIBS_USER }}
          key: ${{ runner.os }}-r-${{ hashFiles('depends.Rds') }}
          restore-keys: ${{ runner.os }}-r-

      - name: Install system dependencies
        env:
          RHUB_PLATFORM: linux-x86_64-ubuntu-gcc
        run: |
          Rscript -e "remotes::install_github('r-hub/sysreqs')"
          sysreqs=$(Rscript -e "cat(sysreqs::sysreq_commands('DESCRIPTION'))")
          sudo -s eval "$sysreqs"
          # rsconnect dependencies
          sudo apt-get update && sudo apt-get install -y --no-install-recommends \
            libxml2-dev libcurl4-openssl-dev
# Install rsconnect necessary for deployment
      - name: Install dependencies
        run: |
          remotes::install_deps(dependencies = TRUE)
          remotes::install_cran(c("rcmdcheck", "rsconnect"))
        shell: Rscript {0}

      - name: Check package
        run: rcmdcheck::rcmdcheck(args = "--no-manual", error_on = "warning", check_dir = "check")
        shell: Rscript {0}

      - name: Deploy to shinyapps.io
        if: github.ref == 'refs/heads/master'
        env:
          SHINYAPPS_ACCOUNT: ${{ secrets.SHINYAPPS_ACCOUNT }}
          SHINYAPPS_TOKEN: ${{ secrets.SHINYAPPS_TOKEN }}
          SHINYAPPS_SECRET: ${{ secrets.SHINYAPPS_SECRET }}
        run: |
          account_info <- lapply(paste0("SHINYAPPS_", c("ACCOUNT", "TOKEN", "SECRET")), Sys.getenv)
          do.call(rsconnect::setAccountInfo, account_info)
          rsconnect::deployApp(appName = "ShinyCICD")
        shell: Rscript {0}
```
