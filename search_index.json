[
["index.html", "Technical Guidelines Introduction", " Technical Guidelines Mirai Solutions 2020-06-19 23:17:43 Introduction Mirai Solutions is happy to share technical guidelines, how-tos and best practices in different areas. "],
["roxygen-documentation-guidelines.html", "1 Roxygen documentation guidelines", " 1 Roxygen documentation guidelines The scope of this document is to provide opinionated yet motivated guidelines and best practices for documenting R objects (especially functions) with roxygen2. This is based on: roxygen2 vignettes: browseVignettes(&quot;roxygen2&quot;), in particular Generating Rd files. The tidyverse style guide. Package development experience. Examples are provided to show the concrete application of the described principles. "],
["general-guidelines-and-documentation-workflow.html", "1.1 General guidelines and documentation workflow", " 1.1 General guidelines and documentation workflow Note that the ultimate goal of documentation is to have meaningful and consolidated help pages. For this reason, being happy about the roxygen tags in the source code is no enough, and the final help pages should always be checked as rendered by help(&lt;TOPIC&gt;). To quickly iterate trough documentation development, updates and checks, the following is recommended. Use devtools::check_man(), which does some basic checks on top of roxygenizing your package, hinting about e.g. undocumented arguments. Assess the development version of the documentation via pkgload::dev_help(&lt;TOPIC&gt;), which is quicker than re-building the whole package and using help(), allowing faster iterations. The final documentation should be then checked using R CMD check (possibly with packages devtools or rcmdcheck), and the help pages assessed with help(&lt;TOPIC&gt;) after installing the package. For larger documentation efforts, it can be worth to generate the full PDF manual, where it is easier to also cross-check consistency at the whole package level. An approach seen too often is to introduce roxygen documentation tags very early in the development of e.g. a function, using simple, pretty-uninformative placeholder tags. Early documentation is very useful if already thought-through upfront, to help thinking about and better design e.g. interfaces, usage, behavior, return values. Early, poor documentation tags only serve the purpose of a skeleton, but may give the wrong impression of an actual documentation effort. Instead, it can be a good idea to add normal comments describing the function behavior (even a single comment saying what the function does). This can be the basis of proper, thought-through documentation tags at a more advanced development stage. Also note that RStudio offers the creation of a roxygen skeleton (Code &gt; Insert Roxygen skeleton or Shift+Ctrl+Alt+), so there is little need / benefit in creating one manually, with poor content, ahead of time. "],
["content-organization.html", "1.2 Content organization", " 1.2 Content organization Content structure and order of the roxygen2 documentation should be organized for readability, alignment with the rendered content, maintainability. Apart from the @title (see below), always use sentence case with a final period (.). Content order should reflect how sections appear in the resulting help page: title, description, arguments, details, value, custom sections, references, see also, examples. Note that @family belongs to the ‘See Also’ section, so place it accordingly. Place @inherit* and @template tags in the relevant place for the content you are including. Use an empty line to separate sections Avoid stating explicit @title and (single-paragraph) @description tags, they will be inferred by position. Put single-paragraph content right after the tag (@details Bla bla.). If you have multi-paragraph content for a single tag, separate the paragraphs with an empty line and start the first paragraph on a new line rather than right after the tag. Note that multi-paragraph description always requires an explicit @description. Place NAMESPACE-related tags @importFrom, @import, @export at the bottom and in this order. Use one @importFrom per symbol (not per package) and try to avoid @import. For un-exported objects documented for internal purposes, specify @keywords internal instead of @export. Use markdown: If not done at package level, @md should be the last element (so it can easily be removed when moving to package-level). Do not use @rdname if not documenting multiple objects (see below). Break lines at 80 characters of content (you can set Tools &gt; Global Options &gt; Code &gt; Display &gt; Margin column: 80 and &gt; Show margin for visual aid): No matter how wide your screen is, human brain is still not meant for processing long text, which would be poorly readable (code is a different story). Use RStudio menu Edit &gt; Reflow comment (Shift+Ctrl+/) after selecting a single block (selecting several parts might screw things up), which will also indent the lines after the first when needed. 1.2.1 Note about @title Keep in mind that the content of @title (the top paragraph, w/o explicit tag as recommended above) is used and displayed for two purposes in the R documentation: Title of the topics help page (the most know and natural usage). Brief description / hint to topics in the package help index (e.g. help(package = &quot;roxygen2&quot;)), a less known and often forgotten usage. With this in mind: You may want to use title case (more natural for 1.) or sentence case (more sensible for 2.), but be consistent within a package (and never add a final period, ugly for 1.). Avoid using the very same topic name as title (e.g. the function name when documenting a function). This does not provide any extra information, especially in the help index, where describing e.g. myFunction as “myFunction” is pretty pointless. "],
["advanced-usage-and-consistent-documentation.html", "1.3 Advanced usage and consistent documentation", " 1.3 Advanced usage and consistent documentation Several techniques and tools are available to enable and support a more consistent and maintainable documentation. This can be described in detail in the Do repeat yourself section of vignette Generating Rd files, and are summarized as follows Cross-link documentation files with @seealso and @family. Reuse parameter documentation with @inherit, @inheritParams, and @inheritSections. Document multiple functions in the same place with @describeIn or @rdname. Run arbitrary R code with @eval. Create reusable templates with @template and @templateVar. 1.3.1 Roxygen templates and example scripts Roxygen templates allow modularizing documentation content. Shared content sits in R files under the man-roxygen directory, and is included using the @template tag. Similarly, examples written as normal R code can be included in the ‘Examples’ section using @example (without s), which for long examples is way more convenient and less tedious than writing them as roxygen comments in the @examples section. The man-roxygen directory must be added to .Rbuildignore, e.g. via usethis::use_build_ignore(&quot;man-roxygen&quot;) Template files should be called &lt;TAG&gt;-&lt;NAME&gt;.R depending on which @&lt;TAG&gt; they contain (typically one per template), and be included according to the corresponding tag order. This improves the readability and maintenance of template-based documentation e.g., param-first_arg.R contains #' @param first_arg Bla bla bla. Markdown must be specified via @md in each template if not defined at package level. Examples R scripts should be called ex-&lt;FUNCTION_NAME&gt;.R and placed in man-roxygen (for convenience). They are then included via @example man-roxygen/ex-&lt;FUNCTION_NAME&gt;.R. 1.3.2 Using @rdname and @describeIn Tags @rdname and @describeIn are a convenient way to document multiple functions in the same file. See the roxygen2 vignette Generating Rd files (vignette(&quot;rd&quot;, package = &quot;roxygen2&quot;)) for more detail. In both case, not that @title should be specified only for the main documentation object, since it will be ignored for others (a help page allowing only one title). It may also be convenient to collect the main generic documentation content as roxygen2 tags for a NULL object with an explicit @name (see examples below). Usage of @rdname @rdname provides the greatest flexibility for combining documentation (description, arguments, details, etc.) of several objects into a single documentation entry. Tag @rdname should the first tag, and should be used exclusively when appending documentation content for a new object to another existing @rdname. Having an @rdname for single and full-documented objects should be avoided since it is redundant and unnecessary; it gives the impression we want to document this object alongside others; it does not help if we later want to change the @rdname to a different topic, since the documentation content must be probably adapted (e.g. @title should be removed as it would be ignored). Usage of @describeIn @describeIn &lt;name&gt; &lt;description&gt; is meant for a set of functions with (almost) same arguments and that can be described in a general way in the ‘Description’ section, whereas individual &lt;description&gt;s are collected in a final section ‘Functions’. Tag @describeIn should be the last tag before the specific @examples and namespace tags (and possibly after specific @param). "],
["examples.html", "1.4 Examples", " 1.4 Examples The following examples make use of the demo package roxygenExPkg. The package can be installed as: remotes::install_github( &quot;miraisolutions/techguides/roxygen-guidelines/roxygenExPkg&quot; ) The command help(package = &quot;roxygenExPkg&quot;) will give you access to the package help. 1.4.1 General content organization See the corresponding ?roxygenExPkg::fun_doc. #&#39; Function Documentation Example #&#39; #&#39; Show an example of roxygen tags organization, providing documentation best #&#39; practices and guidelines. An explicit `@description` is only needed for #&#39; multi-paragraph descriptions. #&#39; #&#39; @param first_arg Description of the first argument. Also define data type / #&#39; class / structure / vectorization expectations where not obvious, and #&#39; possibly use (see &#39;Details&#39;). #&#39; @param second_arg Second argument of the function. #&#39; #&#39; @details More details or context about the function and its behaviour. List #&#39; possible side-effects, corner-cases and limitations here. Also use this #&#39; section for describing the meaning and usage of arguments when this is too #&#39; complex or verbose for the `@param` tags. #&#39; #&#39; @section Custom section: #&#39; The content of a custom section. #&#39; #&#39; @return Returns `NULL`, invisibly. The function is called for illustration #&#39; purposes only. #&#39; #&#39; @references #&#39; Hadley Wickham, Peter Danenberg and Manuel Eugster. roxygen2: In-Line #&#39; Documentation for R. [https://CRAN.R-project.org/package=roxygen2](). #&#39; #&#39; Hadley Wickham, The tidyverse style guide. #&#39; [http://style.tidyverse.org/documentation.html](). #&#39; #&#39; @seealso [fun_doc_tpl()], [roxygen2::roxygenize()]. Even if you just put #&#39; comma-separated links to functions, don&#39;t forget the final period (.). #&#39; @family function documentation examples #&#39; #&#39; @examples #&#39; # illustrate through examples how functions can be used #&#39; fun_doc(&quot;example_string&quot;, 3) #&#39; #&#39; @importFrom roxygen2 roxygenize #&#39; @importFrom roxygen2 roxygenise #&#39; @export #&#39; #&#39; @md fun_doc &lt;- function(first_arg, second_arg) { invisible() } 1.4.2 Templates and example scripts See the corresponding ?roxygenExPkg::fun_doc_tpl. #&#39; Template Documentation Example #&#39; #&#39; Show an example of roxygen tags organization, providing documentation best #&#39; practices and guidelines, using templates. #&#39; #&#39; @template param-first_arg #&#39; @param second_arg Description of the second argument. #&#39; #&#39; @template details-fun_doc #&#39; #&#39; @section Custom section: #&#39; The content of a custom section. #&#39; #&#39; @template return-NULL #&#39; #&#39; @template reference-roxygen2 #&#39; @template reference-tidyverse_style_guide #&#39; #&#39; @seealso [fun_doc_tpl()], [roxygen2::roxygenize()]. Even if you just put #&#39; comma-separated links to functions, don&#39;t forget the final period (.). #&#39; @family function documentation examples #&#39; #&#39; @example man-roxygen/ex-fun_doc_tpl.R #&#39; #&#39; @importFrom roxygen2 roxygenize #&#39; @importFrom roxygen2 roxygenise #&#39; @export #&#39; #&#39; @md fun_doc_tpl &lt;- function(first_arg, second_arg) { invisible() } 1.4.3 @rdname See the corresponding ?roxygenExPkg::divide. #&#39; Scalar Division #&#39; #&#39; Divide an object by a scalar. #&#39; #&#39; @param x The object to be divided #&#39; @param d Scalar to divide `x` by. #&#39; #&#39; @return The result of the scalar division of `x`. #&#39; #&#39; @examples #&#39; x &lt;- matrix(1:6, 3L) #&#39; #&#39; @name divide #&#39; #&#39; @md NULL #&#39; @rdname divide #&#39; #&#39; @details `divide_by()` performes generic division by `d`. #&#39; #&#39; @examples #&#39; divide_by(x, 1.5) #&#39; #&#39; @export #&#39; #&#39; @md divide_by &lt;- function(x, d) { x * d } #&#39; @rdname divide #&#39; #&#39; @details `divide_by2()` performes division by two. #&#39; #&#39; @examples #&#39; divide_by2(x) #&#39; #&#39; @export #&#39; #&#39; @md divide_by2 &lt;- function(x) { divide_by(x, 2) } #&#39; @rdname divide #&#39; #&#39; @details `divide_by3()` performes division by three. #&#39; #&#39; @examples #&#39; divide_by3(x) #&#39; #&#39; @export #&#39; #&#39; @md divide_by3 &lt;- function(x) { divide_by(x, 3) } #&#39; @rdname divide #&#39; #&#39; @details `divide_by4()` performes division by four. #&#39; #&#39; @examples #&#39; divide_by4(x) #&#39; #&#39; @export #&#39; #&#39; @md divide_by4 &lt;- function(x) { divide_by(x, 4) } 1.4.4 @describeIn See the corresponding ?roxygenExPkg::times. #&#39; Scalar Multiplication #&#39; #&#39; Multiply an object by a scalar. #&#39; #&#39; @param x The object to be multiplied. #&#39; @param m Scalar to multiply `x` by. #&#39; #&#39; @return The result of the scalar multiplication of `x`. #&#39; #&#39; @describeIn times Generic multiplication by `m`. #&#39; #&#39; @examples #&#39; x &lt;- matrix(1:6, 3L) #&#39; #&#39; times(x, 1.5) #&#39; #&#39; @export #&#39; #&#39; @md times &lt;- function(x, m) { x * m } #&#39; @describeIn times Multiplication by 2. #&#39; #&#39; @examples #&#39; times2(x) #&#39; #&#39; @export #&#39; #&#39; @md times2 &lt;- function(x) { times(x, 2) } #&#39; @describeIn times Multiplication by 3. #&#39; #&#39; @examples #&#39; times3(x) #&#39; #&#39; @export #&#39; #&#39; @md times3 &lt;- function(x) { times(x, 3) } #&#39; @describeIn times Multiplication by 4. #&#39; #&#39; @examples #&#39; times4(x) #&#39; #&#39; @export #&#39; #&#39; @md times4 &lt;- function(x) { times(x, 4) } "],
["version-stable-r-development-with-docker.html", "2 Version-stable R development with Docker", " 2 Version-stable R development with Docker In the context of productive solutions, it is essential to have full control over the code-base and environment to ensure reproducibility and stability of the setup. In the case of R-based projects, this implies fixing and aligning the version of R as well as package and system dependencies. In order to achieve well-managed release pipelines, a key aspect is to guarantee full equivalence of the development setup to (alternative) target productive stages. This guide illustrates an approach to manage a version-stable R development environment based on containerized solutions leveraging the Rocker project, allowing the coexistence of multiple dockerized development flavors, to match various target production environments or projects. "],
["version-stable-deployments.html", "2.1 Version-stable deployments", " 2.1 Version-stable deployments When deploying R applications (e.g. a Shiny app) using Docker containers, it is important to control versioning of R and packages for the sake of reproducibilty and stability of the deployments. For this reason, version-stable images are provided as part of the Rocker project and used as a basis for deploying productive applications. Each version-stable Rocker image has an associated tag for all non-latest R versions (e.g. rocker/r-ver:3.6.1). Besides being specific to the corresponding version of R, each tag fixes the version of contributed packages (by using as package repository the MRAN snapshot of the last day CRAN distributed that R version as latest release). See VERSIONS.md The Dockerfile of a deployed application then defines a given version-stable image tag to start FROM, e.g. FROM rocker/r-ver:3.6.1 See SmaRP/Dockerfile for an example. "],
["align-local-development-and-deployment-environments.html", "2.2 Align local development and deployment environments", " 2.2 Align local development and deployment environments When developing and testing an app locally, it is important to ensure the environment is aligned with the target deployment environment. This might imply using e.g. multiple R and package versions for the local development of different applications, which clash with the typical setup (especially on Linux systems), where only one R version (the latest release) exists. The idea is then to rely on the same version-stable rocker containers used for the deployments, using a containerized versioned RStudio instance for the local development. This is available through Rocker’s versioned stack, so we could use e.g. rocker/rstudio:3.6.1. Note that the same version-stable instance of RStudio can be used across all different projects for which such version is relevant. For this reason, a sensible choice is to rely on rocker/verse, which adds tidyverse and devtools to the stack, as well as properly setting up R Markdown system dependencies TinyTeX and pandoc, sparing the effort of the tedious extra install. See the specific section below about ‘TinyTeX considerations’. 2.2.1 Running versioned RStudio instances Assume we want to run a containerized versioned instance of RStudio for R 3.6.1, possibly alongside instances for other versions of R. First of all, we need to get the image from docker-hub docker pull rocker/verse:3.6.1 We then want to have a running instance on localhost (127.0.0.1), with the following setup: No authentication required (local setup). Enable root by setting the environment variable ROOT to TRUE, so that e.g. sudo apt-get can be used in RStudio. Use a version-specific port, e.g. 3500 for R 3.5.0, 3610 for R 3.6.1 and so on, so that we can use localhost for concurrent R version instances. The development code of all relevant projects should live outside the container and be shared with it (and possibly many of them), e.g. under ~/RStudioProjects on the host machine and /home/rstudio/RStudioProjects in the container. For this to work w/o permission issues, the container user (rstudio) must match the UID of the host user ($UID). In order for the RStudio setting to persist if the container is recreated (e.g. after pulling a new rocker image), we also use a shared volume (like ~/.rstudio-docker/3.6.1) for the home/rstudio/.rstudio directory, which is version-specific in case of multiple R versions If we want to use Meld via the compareWith addins, we need to map the DISPLAY environment variable and volume /tmp/.X11-unix add DISPLAY to Renviron install Meld install dbus-x11 Use a version-specific name for the container running the RStudio instance, e.g. rstudio_3.6.1. R_VER=3.6.1 SHARED_DIR=RStudioProjects docker run -d --restart=always \\ -p 127.0.0.1:$(echo $R_VER | sed &#39;s/[.]//g&#39;)0:8787 \\ -e DISABLE_AUTH=true \\ -e ROOT=TRUE \\ -e USERID=$UID \\ -v $HOME/$SHARED_DIR:/home/rstudio/$SHARED_DIR \\ -v $HOME/.rstudio-docker/$R_VER:/home/rstudio/.rstudio \\ -e DISPLAY=$DISPLAY \\ -v /tmp/.X11-unix:/tmp/.X11-unix:ro \\ --name rstudio_$R_VER \\ rocker/verse:$R_VER # R and RStudio are not getting the DISPLAY environment variable docker exec rstudio_$R_VER bash -c \\ &#39;echo &quot;DISPLAY=${DISPLAY}&quot; &gt;&gt; /usr/local/lib/R/etc/Renviron&#39; # Install Meld docker exec rstudio_$R_VER bash -c \\ &#39;apt-get update &amp;&amp; apt-get install -y --no-install-recommends meld dbus-x11&#39; The running RStudio can then be accessed by visiting http://localhost:3610/. You may find convenient to define a shell function as follows run_rstudio_ver() { local R_VER=${1:?&quot;you must supply the R version as first argument&quot;} local SHARED_DIR=${2:?&quot;you must supply the shared directory as second argument&quot;} local RVER_IMAGE=${3:-&quot;verse&quot;} local BASE_IMAGE=rocker/$RVER_IMAGE:$R_VER local PORT=$(echo $R_VER | sed &#39;s/[.]//g&#39;)0 local CONTANER_NAME=rstudio_$R_VER echo &quot;Containerized version-stable RStudio for R &quot;$R_VER\\ &quot;based on image &quot;$BASE_IMAGE\\ &quot;with shared volume &quot;$SHARED_DIR docker pull $BASE_IMAGE &amp;&amp; docker run -d --restart=always \\ -p 127.0.0.1:$PORT:8787 \\ -e DISABLE_AUTH=true \\ -e ROOT=TRUE \\ -e USERID=$UID \\ -v $HOME/$SHARED_DIR:/home/rstudio/$SHARED_DIR \\ -v $HOME/.rstudio-docker/$R_VER:/home/rstudio/.rstudio \\ -e DISPLAY=$DISPLAY \\ -v /tmp/.X11-unix:/tmp/.X11-unix:ro \\ --name $CONTANER_NAME \\ $BASE_IMAGE &amp;&amp; # R and RStudio are not getting the DISPLAY environment variable docker exec $CONTANER_NAME bash -c \\ &#39;echo &quot;DISPLAY=${DISPLAY}&quot; &gt;&gt; /usr/local/lib/R/etc/Renviron&#39; &amp;&amp; # Install Meld docker exec $CONTANER_NAME bash -c \\ &#39;apt-get update &amp;&amp; apt-get install -y --no-install-recommends meld dbus-x11&#39; &amp;&amp; echo &quot;RStudio running in container &quot;$CONTANER_NAME&quot; on port &quot;$PORT &amp;&amp; echo &quot;visit http://localhost:&quot;$PORT } which you can re-use as compact command for any R version as follows run_rstudio_ver 3.6.1 RStudioProjects Note that --restart=always specifies that the container should stay up and restart itself after stopping, e.g. upon machine reboot or docker upgrade, so that it is always available. Still, you can explicitly stop the running container with docker stop rstudio_3.6.1 Alternatively, you can omit --restart=always and explicitly start the container whenever needed with docker start rstudio_3.6.1 Note that start/stop operations do not affect the persistence of files created outside the shared location, including global RStudio options such as dark theme, diagnostic, etc. (set via Tools &gt; Global Options…). On the other hand, these files and settings do not (see above) persist removing the container (docker rm, see below) . 2.2.2 TinyTeX considerations 2.2.2.1 pdfcrop Older rocker/verse images might not include pdfcrop, which is required for the default and desirable cropping of PDF figures with R Markdown (see rocker-org/rocker-versioned#146). Make sure pdfcrop is installed by running at R console tinytex::tlmgr_install(&quot;pdfcrop&quot;) (see R Markdown: The Definitive Guide) 2.2.2.2 Align TinyTeX to current remote repo NOTE - This should never be needed with recent rocker/verse images, where a version-stable Tex Live repository is used for the TinyTeX install (see rocker-org/rocker-versioned#169). If you are using LaTeX and start seeing errors like Remote repository is newer than local (2018 &lt; 2019) it means that you have to re-install TinyTeX. This happens e.g. with rocker/verse:3.6.1, since it was build at the end of 2018 but the current Tex Live repo is 2019. You can fix this via a user-specific re-installation of TinyTeX for R. NOTE however that this will uninstall the system-level TinyTeX pre-installed in rocker/verse. First, make sure /home/rstudio/bin is part of the PATH environment variable. Check this by running docker exec --user rstudio rstudio_3.6.1 R --slave -e &#39;Sys.getenv(&quot;PATH&quot;)&#39; If you don’t see /home/rstudio/bin, you can make sure it is part of the PATH for R via docker exec --user rstudio rstudio_3.6.1 sh -c &#39;echo &quot;PATH=$HOME/bin:\\${PATH}&quot; &gt;&gt; $HOME/.Renviron&#39; # check again docker exec --user rstudio rstudio_3.6.1 R --slave -e &#39;Sys.getenv(&quot;PATH&quot;)&#39; Then, from the running RStudio, run tinytex::reinstall_tinytex() 2.2.3 Cleanup docker rm $(docker stop rstudio_3.6.1) "],
["references.html", "2.3 References", " 2.3 References The Rocker Project Shared Volumes Managing Users Managing containers Rocker Wiki Sharing files with host machine "],
["cicd-pypelines-for-automatic-deployment-of-a-r-shiny-web-app.html", "3 CI/CD pypelines for automatic deployment of a R Shiny web app", " 3 CI/CD pypelines for automatic deployment of a R Shiny web app It is good practice to integrate and develop an R Shiny app as an R package, to take full advantage of all the integrated features established for R packages (e.g., documentation, package namespaces, automated testing, R CMD check, etc.). A typical development workflow to package a Shiny app is provided by the golem package. Furthermore, version control systems such as Git are a great asset for keeping track an manage changes, especially in a collaborative setup. The development od packaged Shiny app under version control can easily enable and take advantage of: Continuous Integration (CI) pipelines to automate checks and ensure higher code quality and robustness; Continuous Deployment (CD) pipelines to automate the process of deployment to a productive environment. This guide is illustrates how to set up CI/CD pipelines on the popular free and open source services Travis CI and GitHub Actions for a packaged Shiny app on GitHub repository, deployed and hosted on shinyapps.io. ShinyCICD is a minimal example of a packaged Shiny app that will be used as an example throughout the guide. You can simply fork the repository and setup your specific user settings (especially for shinyapps.io) to see CI/CD pipelines in actions, or follow the steps described below to setup CI/CD pipelines for your own app. "],
["generic-cicd-pipeline.html", "3.1 Generic CI/CD pipeline", " 3.1 Generic CI/CD pipeline Generally speaking, a CI/CD pipeline related to an R package is comprised of the following steps: setup a running environment setup R check out the package source code install system dependencies install package dependencies (with caching) build the package checks the package deploy Most of these steps are implemented by default in Travis CI for an R package. In GitHub Actions, on the other hand, it is currently necessary to manually specify each of them. "],
["travis-ci.html", "3.2 Travis CI", " 3.2 Travis CI Travis CI is an open-source continuous integration service that can be used to build and test software projects hosted on GitHub. To set up Travis CI you need to login at https://travis-ci.com/ (using your GitHub account) and provide authorization via GitHub (see Travis CI Tutorial). 3.2.1 Standard CI setup To setup Travis CI in a project use: usethis::use_travis() # use ext = &quot;com&quot; if usethis &lt; 1.6.0 This will generate a generic .travis.yml file # R for travis: see documentation at https://docs.travis-ci.com/user/languages/r language: R cache: packages As default, Travis CI takes care of package dependency installation and performs the typical package build &amp; check you would run locally via e.g. devtools::check(). Such CI pipeline is triggered by any push event on any branch on the GitHub repo, including pull requests. 3.2.2 Using renv for your project If your project relies on package renv for tracking dependencies via an renv.lock file, you should override the default installation package dependencies and make sure cacheing is adjusted accordingly, as follows cache: directories: - $HOME/.local/share/renv - $TRAVIS_BUILD_DIR/renv/library install: - Rscript -e &quot;if (!requireNamespace(&#39;renv&#39;, quietly = TRUE)) install.packages(&#39;renv&#39;)&quot; - Rscript -e &quot;renv::restore()&quot; as described in the Using renv with Continuous Integration vignette. 3.2.3 Automated deployment Travis CI can be setup to perform a deployment (e.g. publish a shiny app on shinyapps.io) upon any push to the master branch, provided the CI checks pass. This is achieved for a shinyapps.io deployment by specifying in .travis.yml an additional deploy: section as deploy: provider: script skip_cleanup: true # strictly necessary only for the renv case script: - &gt;- Rscript -e &#39;account_info &lt;- lapply(paste0(&quot;SHINYAPPS_&quot;, c(&quot;ACCOUNT&quot;, &quot;TOKEN&quot;, &quot;SECRET&quot;)), Sys.getenv)&#39; -e &#39;do.call(rsconnect::setAccountInfo, account_info)&#39; -e &#39;rsconnect::deployApp(appName = &quot;ShinyCICD&quot;)&#39; on: branch: master where SHINYAPPS_ACCOUNT, SHINYAPPS_TOKEN, SHINYAPPS_SECRET are secure variables defined on Travis CI holding your account name and corresponding tokens for shinyapps.io. It is in fact more convenient to write an R script, saved e.g. as deploy/deploy-shinyapps.R (build-ignored via usethis::use_build_ignore(&quot;deploy&quot;)) defining the deployment commands: # deploy/deploy-shinyapps.R # usethis::use_build_ignore(&quot;deploy&quot;) rsconnect::setAccountInfo( Sys.getenv(&quot;SHINYAPPS_ACCOUNT&quot;), Sys.getenv(&quot;SHINYAPPS_TOKEN&quot;), Sys.getenv(&quot;SHINYAPPS_SECRET&quot;) ) rsconnect::deployApp( appName = &quot;ShinyCICD&quot;, # exclude hidden files and renv directory (if present) appFiles = setdiff(list.files(), &quot;renv&quot;) ) and then simply execute it as deploy script: deploy: provider: script skip_cleanup: true # strictly necessary only for the renv case script: Rscript deploy/deploy-shinyapps.R on: branch: master 3.2.4 Putting it all together The final .travis.yml file (for the non-renv case) would look like # R for travis: see documentation at https://docs.travis-ci.com/user/languages/r language: R cache: packages deploy: provider: script script: Rscript deploy/deploy-shinyapps.R on: branch: master As visible from the run logs, all the CI/CD pipeline steps are performed, despite only the deployment step being explicitly defined. "],
["github-actions.html", "3.3 GitHub Actions", " 3.3 GitHub Actions GitHub Actions is a service for running highly-customizable and flexible automated workflows, fully integrated with GitHub and very suitable to CI/CD pipelines. Workflows use YAML syntax and should be stored in the .github/workflows directory in the root of the repository. Workflows are constituted of jobs and each job is a set of steps to perform individual tasks, e.g. commands or actions. 3.3.1 Workflow steps A workflow should have an identifying name and an on section indicating upon which events the workflow should be triggered. It should include at least one job and each job will have a set of steps fully specifying what to execute. Such steps can be a (predefined) action or a script, however, for the time being, GitHub Actions does not support a hierarchical, aggregated structure of actions. Being fully customizable, it is necessary to fully specify each step in the CI/CD pipeline explicitly. 3.3.1.1 Setup Checkout the source package from the repo, using actions/checkout provided by GitHub. Setup R using action r-lib/actions/setup-r Query and cache R package dependencies using remotes::dev_package_deps() and the actions/cache predefined action. Install system dependencies using package sysreqs::sysreq_commands() (for the ubuntu runner used to run the action) Install R package dependencies using remotes::Install_deps() 3.3.1.2 Package check Check the package via using rcmdcheck::rcmdcheck() 3.3.1.3 Deployment Deploy to shinyapps.io, similar to the Travis CI case In this case, environment variables SHINYAPPS_ACCOUNT, SHINYAPPS_TOKEN and SHINYAPPS_SECRET, defining credentials for shinyapps.io), are specified / accessible as GitHub secrets. An R script e.g. deploy/deploy-shinyapps.R (build-ignored via usethis::use_build_ignore(&quot;deploy&quot;)) defines the deployment commands based on the environment variables: # deploy/deploy-shinyapps.R # usethis::use_build_ignore(&quot;deploy&quot;) rsconnect::setAccountInfo( Sys.getenv(&quot;SHINYAPPS_ACCOUNT&quot;), Sys.getenv(&quot;SHINYAPPS_TOKEN&quot;), Sys.getenv(&quot;SHINYAPPS_SECRET&quot;) ) rsconnect::deployApp( appName = &quot;ShinyCICD&quot;, # exclude hidden files and renv directory (if present) appFiles = setdiff(list.files(), &quot;renv&quot;) ) 3.3.2 Workflow file The steps above are defined in the .yml workflow file as follows # Triggered on push and pull request events on: [push, pull_request] # Name of the workflow =&gt; usethis::use_github_actions_badge(&quot;CI-CD&quot;) name: CI-CD jobs: CI-CD: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: r-lib/actions/setup-r@master - name: Query dependencies shell: Rscript {0} run: | install.packages(&#39;remotes&#39;) saveRDS(remotes::dev_package_deps(dependencies = TRUE), &quot;.github/depends.Rds&quot;, version = 2) writeLines(sprintf(&quot;R-%i.%i&quot;, getRversion()$major, getRversion()$minor), &quot;.github/R-version&quot;) - name: Cache packages uses: actions/cache@v2 with: path: ${{ env.R_LIBS_USER }} key: ${{ runner.os }}-${{ hashFiles(&#39;.github/R-version&#39;) }}-${{ hashFiles(&#39;.github/depends.Rds&#39;) }} restore-keys: | ${{ runner.os }}-${{ hashFiles(&#39;.github/R-version&#39;) }}- - name: Install system dependencies env: RHUB_PLATFORM: linux-x86_64-ubuntu-gcc run: | Rscript -e &quot;remotes::install_github(&#39;r-hub/sysreqs&#39;)&quot; sysreqs=$(Rscript -e &quot;cat(sysreqs::sysreq_commands(&#39;DESCRIPTION&#39;))&quot;) sudo -s eval &quot;$sysreqs&quot; - name: Install dependencies shell: Rscript {0} run: remotes::install_deps(dependencies = TRUE) - name: Check package shell: Rscript {0} run: | install.packages(&quot;rcmdcheck&quot;) rcmdcheck::rcmdcheck(args = &quot;--no-manual&quot;, error_on = &quot;warning&quot;) - name: Deploy to shinyapps.io if: github.ref == &#39;refs/heads/master&#39; env: SHINYAPPS_ACCOUNT: ${{ secrets.SHINYAPPS_ACCOUNT }} SHINYAPPS_TOKEN: ${{ secrets.SHINYAPPS_TOKEN }} SHINYAPPS_SECRET: ${{ secrets.SHINYAPPS_SECRET }} run: Rscript deploy/deploy-shinyapps.R As visible from the run logs, all the CI/CD pipeline steps are performed subsequently, and are identifiable by the name field. 3.3.3 usethis::use_github_action() In order to use the GitHub action workflow above, or its renv-based variant, you can simply: usethis::use_github_action( url = &quot;https://mirai-solutions.ch/techguides/shiny-ci-cd/actions/ci-cd.yml&quot; # &quot;https://mirai-solutions.ch/techguides/shiny-ci-cd/actions/ci-cd-renv.yml&quot; # &quot;https://mirai-solutions.ch/techguides/shiny-ci-cd/actions/ci.yml&quot; # &quot;https://mirai-solutions.ch/techguides/shiny-ci-cd/actions/ci-renv.yml&quot; ) usethis::use_github_actions_badge(&quot;CI-CD&quot;) # or &quot;CI&quot; "]
]
